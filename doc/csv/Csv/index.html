<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Csv (csv.Csv)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">csv</a> &#x00BB; Csv</nav><h1>Module <code>Csv</code></h1><p>Read and write the CSV (comma separated values) format.</p><p>This library should be compatible with <a href="https://tools.ietf.org/html/rfc4180">RFC4180</a> if one sets <code>strip=false</code> in the creation functions.</p><dl><dt>version</dt><dd>2.3</dd></dl><dl><dt>author</dt><dd>Richard Jones &lt;rjones@redhat.com&gt;</dd></dl><dl><dt>author</dt><dd>Christophe Troestler &lt;Christophe.Troestler@umons.ac.be&gt;</dd></dl><nav class="toc"><ul><li><a href="#input/output-objects">Input/output objects</a></li><li><a href="#input">Input</a></li><li><a href="#output">Output</a></li><li><a href="#functions-to-access-rows-when-a-header-is-present">Functions to access rows when a header is present</a></li><li><a href="#functions-acting-on-csv-data-loaded-in-memory">Functions acting on CSV data loaded in memory</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span><span>string list</span> list</span></code></dt><dd><p>Representation of CSV data in memory. This is a list of rows (also called records), each row being a list of columns.</p></dd></dl><section><header><h3 id="input/output-objects"><a href="#input/output-objects" class="anchor"></a>Input/output objects</h3></header><dl><dt class="spec class-type" id="class-type-in_obj_channel"><a href="#class-type-in_obj_channel" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span>  <a href="class-type-in_obj_channel/index.html">in_obj_channel</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></dt><dd><p>The most basic input object for best interoperability.</p></dd></dl><dl><dt class="spec class-type" id="class-type-out_obj_channel"><a href="#class-type-out_obj_channel" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span>  <a href="class-type-out_obj_channel/index.html">out_obj_channel</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></dt><dd><p>The most basic output object for best interoperability.</p></dd></dl></section><section><header><h3 id="input"><a href="#input" class="anchor"></a>Input</h3></header><dl><dt class="spec exception" id="exception-Failure"><a href="#exception-Failure" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Failure</span> <span class="keyword">of</span> int * int * string</code></dt><dd><p><code>Failure(nrecord, nfield, msg)</code> is raised to indicate a parsing error for the field number <code>nfield</code> on the record number <code>nrecord</code>, the description <code>msg</code> says what is wrong. The first record and the first field of a record are numbered <code>1</code> (to correspond to the usual spreadsheet numbering but differing from <code>List.nth</code> of the OCaml representation).</p></dd></dl><dl><dt class="spec type" id="type-std_in_channel"><a href="#type-std_in_channel" class="anchor"></a><code><span class="keyword">type</span> std_in_channel</code><code> = Stdlib.in_channel</code></dt><dd><p>Alias for <code>in_channel</code> in the standard OCaml library.</p></dd></dl><dl><dt class="spec type" id="type-in_channel"><a href="#type-in_channel" class="anchor"></a><code><span class="keyword">type</span> in_channel</code></dt><dd><p>Stateful handle to input CSV files.</p></dd></dl><dl><dt class="spec value" id="val-of_in_obj"><a href="#val-of_in_obj" class="anchor"></a><code><span class="keyword">val</span> of_in_obj : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;strip:bool</span> <span>&#45;&gt;</span> <span>?&#8288;has_header:bool</span> <span>&#45;&gt;</span> <span>?&#8288;header:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fix:bool</span> <span>&#45;&gt;</span> <a href="class-type-in_obj_channel/index.html">in_obj_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a></code></dt><dd><p><code>of_in_obj ?separator ?excel_tricks in_chan</code> creates a new &quot;channel&quot; to access the data in CSV form available from the channel <code>in_chan</code>. Note that data is read on a as-needed basis by the functions <a href="index.html#val-next"><code>next</code></a>, <a href="index.html#val-fold_left"><code>fold_left</code></a>,... so the channel must stay open while these functions are executed. When you are done with the channel, call <a href="index.html#val-close_in"><code>close_in</code></a> to close it.</p><dl><dt>parameter separator</dt><dd><p>What character the separator is. The default is <code>','</code>. You should be aware however that, in the countries where comma is used as a decimal separator, Excel will use <code>';'</code> as the separator.</p></dd></dl><dl><dt>parameter strip</dt><dd><p>Whether to remove the white space around unquoted fields. The default is <code>true</code> for backward compatibility reasons.</p></dd></dl><dl><dt>parameter has_header</dt><dd><p>tells that the first row of the CSV channel is to be interpreted as a header (this row will not be returned by <a href="index.html#val-next"><code>next</code></a>). This is useful to use the functions in the <a href="Rows/index.html"><code>Rows</code></a> module below. Default: <code>false</code>.</p></dd></dl><dl><dt>parameter header</dt><dd><p>Supply the header to use for this CSV channel. If both <code>header</code> and <code>has_header</code> are given, the names of <code>header</code> take precedence; if a name in <code>header</code> is <code>&quot;&quot;</code>, the one in the CSV header is used. If a name appears twice, only its first occurrence is used.</p></dd></dl><dl><dt>parameter backslash_escape</dt><dd><p>Whether to allow \&quot;, \n,... in quoted fields. This is used by MySQL for example but is not standard CSV so it is set to <code>false</code> by default.</p></dd></dl><dl><dt>parameter excel_tricks</dt><dd><p>enables Excel tricks, namely the fact that '&quot;' followed by '0' in a quoted string means ASCII NULL and the fact that a field of the form =&quot;...&quot; only returns the string inside the quotes. Default: <code>true</code>.</p></dd></dl><dl><dt>parameter fix</dt><dd><p>Parses the CSV data without raising the exception <code>Csv.Failure</code>. If the data does not conform to the CSV format (e.g. because of badly escaped quotes), try to repair it. Default: <code>false</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-of_channel"><a href="#val-of_channel" class="anchor"></a><code><span class="keyword">val</span> of_channel : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;strip:bool</span> <span>&#45;&gt;</span> <span>?&#8288;has_header:bool</span> <span>&#45;&gt;</span> <span>?&#8288;header:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fix:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-std_in_channel">std_in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a></code></dt><dd><p>Same as <a href="index.html#val-of_in_obj"><code>Csv.of_in_obj</code></a> except that the data is read from a standard channel. Note that, because the data is read on a as-needed basis, the <code>std_in_channel</code> must stay open while you are reading data.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;strip:bool</span> <span>&#45;&gt;</span> <span>?&#8288;has_header:bool</span> <span>&#45;&gt;</span> <span>?&#8288;header:<span>string list</span></span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fix:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a></code></dt><dd><p>Same as <a href="index.html#val-of_in_obj"><code>Csv.of_in_obj</code></a> except that the data is read from a string.</p></dd></dl><dl><dt class="spec value" id="val-load"><a href="#val-load" class="anchor"></a><code><span class="keyword">val</span> load : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;strip:bool</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fix:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>load fname</code> loads the CSV file <code>fname</code>. If <code>filename</code> is <code>&quot;-&quot;</code> then load from <code>stdin</code>.</p><dl><dt>parameter separator</dt><dd><p>What character the separator is. The default is <code>','</code>. You should be aware however that, in the countries where comma is used as a decimal separator, Excel will use <code>';'</code> as the separator.</p></dd></dl><dl><dt>parameter backslash_escape</dt><dd><p>Whether to allow \&quot;, \n,... in quoted fields. This is used by MySQL for example but is not standard CSV so it is set to <code>false</code> by default.</p></dd></dl><dl><dt>parameter excel_tricks</dt><dd><p>enables Excel tricks, namely the fact that '&quot;' followed by '0' in a quoted string means ASCII NULL and the fact that a field of the form =&quot;...&quot; only returns the string inside the quotes. Default: <code>true</code>.</p></dd></dl><dl><dt>parameter fix</dt><dd><p>Fix invalid CSV in order to parse it without raising <code>Csv.Failure</code>. See <a href="index.html#val-of_in_obj"><code>of_in_obj</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-load_in"><a href="#val-load_in" class="anchor"></a><code><span class="keyword">val</span> load_in : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;strip:bool</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fix:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-std_in_channel">std_in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>load_in ch</code> loads a CSV file from the input channel <code>ch</code>. See <a href="index.html#val-load"><code>Csv.load</code></a> for the meaning of <code>separator</code> and <code>excel_tricks</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_in_obj"><a href="#val-to_in_obj" class="anchor"></a><code><span class="keyword">val</span> to_in_obj : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <a href="class-type-in_obj_channel/index.html">in_obj_channel</a></code></dt><dd><p>For efficiency reasons, the <code>in_channel</code> buffers the data from the original channel. If you want to examine the data by other means than the methods below (say after a failure), you need to use this function in order not to &quot;loose&quot; data in the buffer.</p></dd></dl><dl><dt class="spec value" id="val-close_in"><a href="#val-close_in" class="anchor"></a><code><span class="keyword">val</span> close_in : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>close_in ic</code> closes the channel <code>ic</code>. The underlying channel is closed as well.</p></dd></dl><dl><dt class="spec value" id="val-next"><a href="#val-next" class="anchor"></a><code><span class="keyword">val</span> next : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p><code>next ic</code> returns the next record in the CSV file.</p><dl><dt>raises End_of_file</dt><dd><p>if no more record can be read.</p></dd></dl><dl><dt>raises Csv.Failure</dt><dd><p>if the CSV format is not respected. The partial record read is available with <a href="index.html#val-current_record"><code>Csv.current_record</code></a>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_left f a ic</code> computes (f ... (f (f a r0) r1) ... rN) where r1,...,rN are the records in the CSV file. If <code>f</code> raises an exception, the record available at that moment is accessible through <a href="index.html#val-current_record"><code>Csv.current_record</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : <span>f:<span>(<span>string list</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_right f ic a</code> computes (f r1 ... (f rN-1 (f rN a)) ...) where r1,...,rN-1, rN are the records in the CSV file. All records are read before applying <code>f</code> so this method is not convenient if your file is large.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>f:<span>(<span>string list</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f ic</code> iterates <code>f</code> on all remaining records. If <code>f</code> raises an exception, the record available at that moment is accessible through <a href="index.html#val-current_record"><code>Csv.current_record</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-input_all"><a href="#val-input_all" class="anchor"></a><code><span class="keyword">val</span> input_all : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>input_all ic</code> return a list of the CSV records till the end of the file.</p></dd></dl><dl><dt class="spec value" id="val-current_record"><a href="#val-current_record" class="anchor"></a><code><span class="keyword">val</span> current_record : <a href="index.html#type-in_channel">in_channel</a> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p>The current record under examination. This is useful in order to gather the parsed data in case of <code>Failure</code>.</p></dd></dl><dl><dt class="spec value" id="val-load_rows"><a href="#val-load_rows" class="anchor"></a><code><span class="keyword">val</span> load_rows : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;strip:bool</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;fix:bool</span> <span>&#45;&gt;</span> <span>(<span>string list</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-std_in_channel">std_in_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><dl><dt>deprecated</dt><dd><p>use <a href="index.html#val-iter"><code>Csv.iter</code></a> on a <a href="index.html#type-in_channel"><code>Csv.in_channel</code></a> created with <a href="index.html#val-of_channel"><code>Csv.of_channel</code></a>.</p></dd></dl></dd></dl></section><section><header><h3 id="output"><a href="#output" class="anchor"></a>Output</h3></header><dl><dt class="spec type" id="type-std_out_channel"><a href="#type-std_out_channel" class="anchor"></a><code><span class="keyword">type</span> std_out_channel</code><code> = Stdlib.out_channel</code></dt><dd><p>Alias for <code>out_channel</code> in the standard OCaml library.</p></dd></dl><dl><dt class="spec type" id="type-out_channel"><a href="#type-out_channel" class="anchor"></a><code><span class="keyword">type</span> out_channel</code></dt></dl><dl><dt class="spec value" id="val-to_out_obj"><a href="#val-to_out_obj" class="anchor"></a><code><span class="keyword">val</span> to_out_obj : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;quote_all:bool</span> <span>&#45;&gt;</span> <a href="class-type-out_obj_channel/index.html">out_obj_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-out_channel">out_channel</a></code></dt><dd><p><code>to_out_obj ?separator ?excel_tricks out_chan</code> creates a new &quot;channel&quot; to output the data in CSV form.</p><dl><dt>parameter separator</dt><dd><p>What character the separator is. The default is <code>','</code>.</p></dd></dl><dl><dt>parameter backslash_escape</dt><dd><p>Prefer to escape the separator in a quoted string with a backslash (e.g. &quot;\&quot;&quot;) instead of doubling it. Also backslash-escape '\n', '\r', '\t', '\b', '\026' (as '\Z') and '\000' (as '\0'). This is nice for interoperability but is nonstandard CSV so it is set to <code>false</code> by default.</p></dd></dl><dl><dt>parameter excel_tricks</dt><dd><p>enables Excel tricks, namely the fact that '\000' is represented as '&quot;' followed by '0' and the fact that a field with leading or trailing spaces or a leading '0' will be encoded as =&quot;...&quot; (to avoid Excel &quot;helping&quot; you). Default: <code>false</code>.</p></dd></dl><dl><dt>parameter quote_all</dt><dd><p>force all fields to be quoted, even if this is not required by the CSV specification.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_channel"><a href="#val-to_channel" class="anchor"></a><code><span class="keyword">val</span> to_channel : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;quote_all:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-std_out_channel">std_out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-out_channel">out_channel</a></code></dt><dd><p>Same as <a href="index.html#val-to_out_obj"><code>Csv.to_out_obj</code></a> but output to a standard channel.</p></dd></dl><dl><dt class="spec value" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span class="keyword">val</span> to_buffer : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;quote_all:bool</span> <span>&#45;&gt;</span> Stdlib.Buffer.t <span>&#45;&gt;</span> <a href="index.html#type-out_channel">out_channel</a></code></dt><dd><p>Same as <a href="index.html#val-to_out_obj"><code>Csv.to_out_obj</code></a> but output to a buffer.</p></dd></dl><dl><dt class="spec value" id="val-close_out"><a href="#val-close_out" class="anchor"></a><code><span class="keyword">val</span> close_out : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>close_out oc</code> close the channel <code>oc</code>. The underlying channel is closed as well.</p></dd></dl><dl><dt class="spec value" id="val-output_record"><a href="#val-output_record" class="anchor"></a><code><span class="keyword">val</span> output_record : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>output_record oc r</code> write the record <code>r</code> is CSV form to the channel <code>oc</code>.</p></dd></dl><dl><dt class="spec value" id="val-output_all"><a href="#val-output_all" class="anchor"></a><code><span class="keyword">val</span> output_all : <a href="index.html#type-out_channel">out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>output_all oc csv</code> outputs all records in <code>csv</code> to the channel <code>oc</code>.</p></dd></dl><dl><dt class="spec value" id="val-save_out"><a href="#val-save_out" class="anchor"></a><code><span class="keyword">val</span> save_out : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-std_out_channel">std_out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><dl><dt>deprecated</dt><dd><p>Save <a href="index.html#type-t"><code>Csv.t</code></a> to a channel.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-save"><a href="#val-save" class="anchor"></a><code><span class="keyword">val</span> save : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;quote_all:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>save fname csv</code> saves the <code>csv</code> data to the file <code>fname</code>.</p></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : <span>?&#8288;separator:char</span> <span>&#45;&gt;</span> <span>?&#8288;backslash_escape:bool</span> <span>&#45;&gt;</span> <span>?&#8288;excel_tricks:bool</span> <span>&#45;&gt;</span> <span>?&#8288;quote_all:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the CSV data.</p></dd></dl><dl><dt class="spec value" id="val-print_readable"><a href="#val-print_readable" class="anchor"></a><code><span class="keyword">val</span> print_readable : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print the CSV data to <code>stdout</code> in a human-readable format. Not much is guaranteed about how the CSV is printed, except that it will be easier to follow than a &quot;raw&quot; output done with <a href="index.html#val-print"><code>Csv.print</code></a>. This is a one-way operation. There is no easy way to parse the output of this command back into CSV data.</p></dd></dl><dl><dt class="spec value" id="val-save_out_readable"><a href="#val-save_out_readable" class="anchor"></a><code><span class="keyword">val</span> save_out_readable : <a href="index.html#type-std_out_channel">std_out_channel</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>As for <a href="index.html#val-print_readable"><code>Csv.print_readable</code></a>, allowing the output to be sent to a channel.</p></dd></dl></section><section><header><h3 id="functions-to-access-rows-when-a-header-is-present"><a href="#functions-to-access-rows-when-a-header-is-present" class="anchor"></a>Functions to access rows when a header is present</h3></header><dl><dt class="spec module" id="module-Row"><a href="#module-Row" class="anchor"></a><code><span class="keyword">module</span> <a href="Row/index.html">Row</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A row with a header.</p></dd></dl><dl><dt class="spec module" id="module-Rows"><a href="#module-Rows" class="anchor"></a><code><span class="keyword">module</span> <a href="Rows/index.html">Rows</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Accessing rows (when a header was provided).</p></dd></dl></section><section><header><h3 id="functions-acting-on-csv-data-loaded-in-memory"><a href="#functions-acting-on-csv-data-loaded-in-memory" class="anchor"></a>Functions acting on CSV data loaded in memory</h3></header><dl><dt class="spec value" id="val-lines"><a href="#val-lines" class="anchor"></a><code><span class="keyword">val</span> lines : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Return the number of lines in a CSV data.</p></dd></dl><dl><dt class="spec value" id="val-columns"><a href="#val-columns" class="anchor"></a><code><span class="keyword">val</span> columns : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Work out the (maximum) number of columns in a CSV file. Note that each line may be a different length, so this finds the one with the most columns.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : <span>?&#8288;top:bool</span> <span>&#45;&gt;</span> <span>?&#8288;left:bool</span> <span>&#45;&gt;</span> <span>?&#8288;right:bool</span> <span>&#45;&gt;</span> <span>?&#8288;bottom:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>This takes a CSV file and trims empty cells.</p><p>All four of the option arguments (<code>~top</code>, <code>~left</code>, <code>~right</code>, <code>~bottom</code>) default to <code>true</code>.</p><p>The exact behaviour is:</p><p><code>~right</code>: If true, remove any empty cells at the right hand end of any row. The number of columns in the resulting CSV structure will not necessarily be the same for each row.</p><p><code>~top</code>: If true, remove any empty rows (no cells, or containing just empty cells) from the top of the CSV structure.</p><p><code>~bottom</code>: If true, remove any empty rows from the bottom of the CSV structure.</p><p><code>~left</code>: If true, remove any empty columns from the left of the CSV structure. Note that <code>~left</code> and <code>~right</code> are quite different: <code>~left</code> considers the whole CSV structure, whereas <code>~right</code> considers each row in isolation.</p></dd></dl><dl><dt class="spec value" id="val-square"><a href="#val-square" class="anchor"></a><code><span class="keyword">val</span> square : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make the CSV data &quot;square&quot; (actually rectangular). This pads out each row with empty cells so that all rows are the same length as the longest row. After this operation, every row will have length <a href="index.html#val-columns"><code>Csv.columns</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-is_square"><a href="#val-is_square" class="anchor"></a><code><span class="keyword">val</span> is_square : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return true iff the CSV is &quot;square&quot; (actually rectangular). This means that each row has the same number of cells.</p></dd></dl><dl><dt class="spec value" id="val-set_columns"><a href="#val-set_columns" class="anchor"></a><code><span class="keyword">val</span> set_columns : <span>cols:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_columns cols csv</code> makes the CSV data square by forcing the width to the given number of <code>cols</code>. Any short rows are padded with blank cells. Any long rows are truncated.</p></dd></dl><dl><dt class="spec value" id="val-set_rows"><a href="#val-set_rows" class="anchor"></a><code><span class="keyword">val</span> set_rows : <span>rows:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_rows rows csv</code> makes the CSV data have exactly <code>rows</code> rows by adding empty rows or truncating rows as necessary.</p><p>Note that <code>set_rows</code> does not make the CSV square. If you want it to be square, call either <a href="index.html#val-square"><code>Csv.square</code></a> or <a href="index.html#val-set_columns"><code>Csv.set_columns</code></a> after.</p></dd></dl><dl><dt class="spec value" id="val-set_size"><a href="#val-set_size" class="anchor"></a><code><span class="keyword">val</span> set_size : <span>rows:int</span> <span>&#45;&gt;</span> <span>cols:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>set_size rows cols csv</code> makes the CSV data square by forcing the size to <code>rows * cols</code>, adding blank cells or truncating as necessary. It is the same as calling <code>set_columns cols
      (set_rows rows csv)</code></p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <span>r:int</span> <span>&#45;&gt;</span> <span>c:int</span> <span>&#45;&gt;</span> <span>rows:int</span> <span>&#45;&gt;</span> <span>cols:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sub r c rows cols csv</code> returns a subset of <code>csv</code>. The subset is defined as having top left corner at row <code>r</code>, column <code>c</code> (counting from <code>0</code>) and being <code>rows</code> deep and <code>cols</code> wide.</p><p>The returned CSV will be &quot;square&quot;.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Compare two CSV files for equality, ignoring blank cells at the end of a row, and empty rows appended to one or the other. This is &quot;semantic&quot; equality - roughly speaking, the two CSV files would look the same if opened in a spreadsheet program.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenate CSV files so that they appear side by side, arranged left to right across the page. Each CSV file (except the final one) is first squared.</p><p>(To concatenate CSV files so that they appear from top to bottom, just use <code>List.concat</code>).</p></dd></dl><dl><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val</span> transpose : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Permutes the lines and columns of the CSV data. Nonexistent cells become empty cells after transpose if they must be created.</p></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>string array</span> array</span></code></dt><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span><span>string array</span> array</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convenience functions to convert to and from a matrix representation. <code>to_array</code> will produce a ragged matrix (not all rows will have the same length) unless you call <a href="index.html#val-square"><code>Csv.square</code></a> first.</p></dd></dl><dl><dt class="spec value" id="val-associate"><a href="#val-associate" class="anchor"></a><code><span class="keyword">val</span> associate : <span>string list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><span>(string * string)</span> list</span> list</span></code></dt><dd><p><code>associate header data</code> takes a block of data and converts each row in turn into an assoc list which maps column header to data cell.</p><p>Typically a spreadsheet will have the format:</p><pre>      header1   header2   header3
      data11    data12    data13
      data21    data22    data23
      ...</pre><p>This function arranges the data into a more usable form which is robust against changes in column ordering. The output of the function is:</p><pre>      [ [&quot;header1&quot;, &quot;data11&quot;; &quot;header2&quot;, &quot;data12&quot;; &quot;header3&quot;, &quot;data13&quot;];
        [&quot;header1&quot;, &quot;data21&quot;; &quot;header2&quot;, &quot;data22&quot;; &quot;header3&quot;, &quot;data23&quot;];
        etc. ]</pre><p>Each row is turned into an assoc list (see <code>List.assoc</code>).</p><p>If a row is too short, it is padded with empty cells (<code>&quot;&quot;</code>). If a row is too long, it is truncated.</p><p>You would typically call this function as:</p><pre><code class="ml">let header, data = match csv with h :: d -&gt; h, d | [] -&gt; assert false;;
let data = Csv.associate header data;;</code></pre><p>The header strings are shared, so the actual space in memory consumed by the spreadsheet is not much larger.</p></dd></dl><dl><dt class="spec value" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span class="keyword">val</span> combine : <span>header:<span>string list</span></span> <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span><span>(string * string)</span> list</span></code></dt><dd><p><code>combine ~header row</code> returns a row with elements <code>(h, x)</code> where <code>h</code> is the header name and <code>x</code> the corresponding row entry. If the <code>row</code> has less entries than <code>header</code>, they are interpreted as being empty. See <a href="index.html#val-associate"><code>associate</code></a> which applies this function to all rows.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>f:<span>(string <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f csv</code> applies <code>f</code> to all entries of <code>csv</code> and returns the resulting CSV.</p></dd></dl></section></div></body></html>